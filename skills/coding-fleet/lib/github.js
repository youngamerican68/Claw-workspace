/**
 * GitHub Integration for Coding Agent Fleet
 * 
 * Handles PR creation, ghost commits, and status updates
 */

const { execSync } = require('child_process');

class GitHubIntegration {
  constructor(config = {}) {
    this.config = {
      ghost_branch_prefix: 'ghost/',
      auto_rollback: true,
      ...config
    };
  }

  /**
   * Create a ghost branch for experimentation
   */
  createGhostBranch(name) {
    const branchName = `${this.config.ghost_branch_prefix}${name}`;
    
    try {
      // Create and checkout new branch
      execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });
      
      console.log(`üëª Created ghost branch: ${branchName}`);
      return { branch: branchName, created: true };
    } catch (error) {
      console.error('Failed to create ghost branch:', error.message);
      throw error;
    }
  }

  /**
   * Commit changes with agent attribution
   */
  ghostCommit(files, agentName, message) {
    const commitMessage = `[ghost] ${agentName}: ${message}`;
    
    try {
      // Stage files
      files.forEach(file => {
        execSync(`git add "${file}"`, { stdio: 'ignore' });
      });
      
      // Commit
      execSync(`git commit -m "${commitMessage}"`, { stdio: 'inherit' });
      
      // Get commit hash
      const commitHash = execSync('git rev-parse HEAD').toString().trim();
      
      console.log(`‚úÖ Ghost commit: ${commitHash.substring(0, 7)} - ${commitMessage}`);
      
      return {
        hash: commitHash,
        message: commitMessage,
        files
      };
    } catch (error) {
      console.error('Ghost commit failed:', error.message);
      throw error;
    }
  }

  /**
   * Push ghost branch to remote
   */
  pushGhostBranch(branch) {
    try {
      execSync(`git push -u origin ${branch}`, { stdio: 'inherit' });
      return { pushed: true, branch };
    } catch (error) {
      console.error('Push failed:', error.message);
      throw error;
    }
  }

  /**
   * Create PR from ghost branch
   */
  createPR(branch, title, body) {
    try {
      const prUrl = execSync(
        `gh pr create --head ${branch} --title "${title}" --body "${body}"`,
        { encoding: 'utf8' }
      );
      
      console.log(`üîó Created PR: ${prUrl}`);
      return { url: prUrl, branch };
    } catch (error) {
      console.error('PR creation failed:', error.message);
      throw error;
    }
  }

  /**
   * Rollback: close PR and delete branch
   */
  async rollback(branch, reason) {
    console.log(`‚è™ Rolling back ${branch}: ${reason}`);
    
    try {
      // Close any open PRs
      execSync(`gh pr close ${branch} --comment "${reason}"`, { stdio: 'ignore' });
      
      // Delete remote branch
      execSync(`git push origin --delete ${branch}`, { stdio: 'ignore' });
      
      // Delete local branch
      execSync(`git branch -D ${branch}`, { stdio: 'ignore' });
      
      console.log(`üóëÔ∏è  Rolled back and deleted ${branch}`);
      return { rolled_back: true, branch };
    } catch (error) {
      console.error('Rollback failed:', error.message);
      return { rolled_back: false, error: error.message };
    }
  }

  /**
   * Promote ghost branch to real PR
   */
  promoteToRealPR(branch) {
    const title = branch.replace(this.config.ghost_branch_prefix, '');
    const body = `Promoted from ghost branch ${branch}\n\nAgents: coder, reviewer, tester`;
    
    return this.createPR(branch, title, body);
  }

  /**
   * Post comment on PR with agent results
   */
  postAgentStatus(prNumber, agentResults) {
    const statusTable = agentResults.map(r => {
      const icon = r.error ? '‚ùå' : '‚úÖ';
      return `| ${icon} | ${r.agent} | ${r.error || 'Completed'} |`;
    }).join('\n');
    
    const body = `## ü§ñ Agent Fleet Results

| Status | Agent | Result |
|--------|-------|--------|
${statusTable}

*Generated by OpenClaw Coding Fleet*`;

    try {
      execSync(`gh pr comment ${prNumber} --body "${body}"`, { stdio: 'inherit' });
      return { posted: true };
    } catch (error) {
      console.error('Failed to post comment:', error.message);
      return { posted: false, error: error.message };
    }
  }

  /**
   * Check if current directory is a git repo
   */
  isGitRepo() {
    try {
      execSync('git rev-parse --git-dir', { stdio: 'ignore' });
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get current branch
   */
  getCurrentBranch() {
    return execSync('git branch --show-current').toString().trim();
  }
}

module.exports = { GitHubIntegration };