"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.videoCodecOption = exports.getOutputCodecOrUndefined = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const codec_1 = require("../codec");
const get_extension_from_codec_1 = require("../get-extension-from-codec");
const get_extension_of_filename_1 = require("../get-extension-of-filename");
let codec;
const setCodec = (newCodec) => {
    if (newCodec === undefined) {
        codec = undefined;
        return;
    }
    if (!codec_1.validCodecs.includes(newCodec)) {
        throw new Error(`Codec must be one of the following: ${codec_1.validCodecs.join(', ')}, but got ${newCodec}`);
    }
    codec = newCodec;
};
const getOutputCodecOrUndefined = () => {
    return codec;
};
exports.getOutputCodecOrUndefined = getOutputCodecOrUndefined;
const deriveCodecsFromFilename = (extension) => {
    var _a, _b;
    if (extension === null) {
        return { possible: [], default: null };
    }
    return {
        default: (_a = get_extension_from_codec_1.defaultCodecsForFileExtension[extension]) !== null && _a !== void 0 ? _a : null,
        possible: (_b = (0, get_extension_from_codec_1.makeFileExtensionMap)()[extension]) !== null && _b !== void 0 ? _b : [],
    };
};
const cliFlag = 'codec';
exports.videoCodecOption = {
    name: 'Codec',
    cliFlag,
    description: () => (jsx_runtime_1.jsx(jsx_runtime_1.Fragment, { children: "H264 works well in most cases, but sometimes it's worth going for a different codec. WebM achieves higher compression but is slower to render. WebM, GIF and ProRes support transparency." })),
    ssrName: 'codec',
    docLink: 'https://www.remotion.dev/docs/encoding/#choosing-a-codec',
    type: '',
    getValue: ({ commandLine }, { compositionCodec, configFile, downloadName, outName, uiCodec, }) => {
        if (uiCodec) {
            return { value: uiCodec, source: 'via UI' };
        }
        const downloadNameExtension = (0, get_extension_of_filename_1.getExtensionOfFilename)(downloadName);
        const outNameExtension = (0, get_extension_of_filename_1.getExtensionOfFilename)(outName);
        const derivedDownloadCodecs = deriveCodecsFromFilename(downloadNameExtension);
        const derivedOutNameCodecs = deriveCodecsFromFilename(outNameExtension);
        if (derivedDownloadCodecs.possible.length > 0 &&
            derivedOutNameCodecs.possible.length > 0 &&
            derivedDownloadCodecs.possible.join('') !==
                derivedOutNameCodecs.possible.join('')) {
            throw new TypeError(`The download name is ${downloadName} but the output name is ${outName}. The file extensions must match`);
        }
        const cliArgument = commandLine[cliFlag];
        if (cliArgument) {
            if (derivedDownloadCodecs.possible.length > 0 &&
                derivedDownloadCodecs.possible.indexOf(cliArgument) === -1) {
                throw new TypeError(`The download name is ${downloadName} but --codec=${cliArgument} was passed. The download name implies a codec of ${derivedDownloadCodecs.possible.join(' or ')} which does not align with the --codec flag.`);
            }
            if (derivedOutNameCodecs.possible.length > 0 &&
                derivedOutNameCodecs.possible.indexOf(cliArgument) === -1) {
                throw new TypeError(`The out name is ${outName} but --codec=${cliArgument} was passed. The out name implies a codec of ${derivedOutNameCodecs.possible.join(' or ')} which does not align with the --codec flag.`);
            }
            return { value: cliArgument, source: 'from --codec flag' };
        }
        if (derivedDownloadCodecs.possible.length > 0) {
            return {
                value: derivedDownloadCodecs.default,
                source: 'derived from download name',
            };
        }
        if (derivedOutNameCodecs.possible.length > 0) {
            if (compositionCodec &&
                derivedOutNameCodecs.possible.includes(compositionCodec)) {
                return {
                    value: compositionCodec,
                    source: 'derived from out name + compositionCodec from calculateMetadata',
                };
            }
            if (configFile && derivedOutNameCodecs.possible.includes(configFile)) {
                return {
                    value: configFile,
                    source: 'derived from out name + config file',
                };
            }
            return {
                value: derivedOutNameCodecs.default,
                source: 'derived from out name',
            };
        }
        if (compositionCodec) {
            return { value: compositionCodec, source: 'via calculateMetadata' };
        }
        if (configFile) {
            return {
                value: configFile,
                source: 'Config file',
            };
        }
        return { value: codec_1.DEFAULT_CODEC, source: 'default' };
    },
    setConfig: setCodec,
};
