"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultBrowserDownloadProgress = void 0;
const renderer_1 = require("@remotion/renderer");
const chalk_1 = require("./chalk");
const log_1 = require("./log");
const make_progress_bar_1 = require("./make-progress-bar");
const progress_bar_1 = require("./progress-bar");
const should_use_non_overlaying_logger_1 = require("./should-use-non-overlaying-logger");
const truthy_1 = require("./truthy");
const makeDownloadProgress = ({ bytesDownloaded, totalBytes, doneIn, chromeMode, }) => {
    const progress = bytesDownloaded / totalBytes;
    return [
        `${doneIn ? 'Got' : 'Getting'} ${chromeMode === 'chrome-for-testing'
            ? 'Chrome for Testing'
            : 'Headless Shell'}`.padEnd(progress_bar_1.LABEL_WIDTH, ' '),
        (0, make_progress_bar_1.makeProgressBar)(progress, false),
        doneIn === null
            ? (progress * 100).toFixed(0) + '%'
            : chalk_1.chalk.gray(`${doneIn}ms`),
    ]
        .filter(truthy_1.truthy)
        .join(' ');
};
const defaultBrowserDownloadProgress = ({ indent, logLevel, quiet, onProgress, }) => {
    return ({ chromeMode }) => {
        if (chromeMode === 'chrome-for-testing') {
            log_1.Log.info({ indent, logLevel }, 'Downloading Chrome for Testing https://www.remotion.dev/chrome-for-testing');
        }
        else {
            log_1.Log.info({ indent, logLevel }, chalk_1.chalk.gray('Downloading Chrome Headless Shell https://www.remotion.dev/chrome-headless-shell'));
        }
        const updatesDontOverwrite = (0, should_use_non_overlaying_logger_1.shouldUseNonOverlayingLogger)({ logLevel });
        const productName = chromeMode === 'chrome-for-testing'
            ? 'Chrome for Testing'
            : 'Headless Shell';
        if (updatesDontOverwrite) {
            let lastProgress = 0;
            return {
                version: null,
                onProgress: (progress) => {
                    if (progress.downloadedBytes > lastProgress + 10000000) {
                        lastProgress = progress.downloadedBytes;
                        log_1.Log.info({ indent, logLevel }, `Getting ${productName} - ${renderer_1.RenderInternals.toMegabytes(progress.downloadedBytes)}/${renderer_1.RenderInternals.toMegabytes(progress.totalSizeInBytes)}`);
                    }
                    if (progress.percent === 1) {
                        log_1.Log.info({ indent, logLevel }, `Got ${productName}`);
                    }
                },
            };
        }
        const cliOutput = (0, progress_bar_1.createOverwriteableCliOutput)({
            quiet,
            indent,
            cancelSignal: null,
            updatesDontOverwrite,
        });
        const startedAt = Date.now();
        let doneIn = null;
        return {
            version: null,
            onProgress: (progress) => {
                if (progress.percent === 1) {
                    doneIn = Date.now() - startedAt;
                }
                onProgress({
                    alreadyAvailable: progress.alreadyAvailable,
                    progress: progress.percent,
                    doneIn,
                });
                cliOutput.update(makeDownloadProgress({
                    doneIn,
                    bytesDownloaded: progress.downloadedBytes,
                    totalBytes: progress.totalSizeInBytes,
                    chromeMode,
                }), progress.percent === 1);
            },
        };
    };
};
exports.defaultBrowserDownloadProgress = defaultBrowserDownloadProgress;
