/**
 * Copyright (c) 2025 Remotion AG
 * For licensing, see: https://remotion.dev/docs/webcodecs#license
 */
import type { MediaParserAudioTrack, MediaParserInternalTypes, MediaParserLogLevel, MediaParserVideoTrack, Options, ParseMediaFields, ParseMediaOptions } from '@remotion/media-parser';
import type { ConvertMediaAudioCodec } from './get-available-audio-codecs';
import { type ConvertMediaContainer } from './get-available-containers';
import { type ConvertMediaVideoCodec } from './get-available-video-codecs';
import { type ConvertMediaOnAudioTrackHandler } from './on-audio-track-handler';
import { type ConvertMediaOnVideoTrackHandler } from './on-video-track-handler';
import type { ResizeOperation } from './resizing/mode';
import { type WebCodecsController } from './webcodecs-controller';
export type ConvertMediaProgress = {
    decodedVideoFrames: number;
    decodedAudioFrames: number;
    encodedVideoFrames: number;
    encodedAudioFrames: number;
    bytesWritten: number;
    millisecondsWritten: number;
    expectedOutputDurationInMs: number | null;
    overallProgress: number | null;
};
export type ConvertMediaResult = {
    save: () => Promise<Blob>;
    remove: () => Promise<void>;
    finalState: ConvertMediaProgress;
};
export type ConvertMediaOnProgress = (state: ConvertMediaProgress) => void;
export type ConvertMediaOnVideoFrame = (options: {
    frame: VideoFrame;
    track: MediaParserVideoTrack;
}) => Promise<VideoFrame> | VideoFrame;
export type ConvertMediaOnAudioData = (options: {
    audioData: AudioData;
    track: MediaParserAudioTrack;
}) => Promise<AudioData> | AudioData;
export declare const convertMedia: <F extends Options<ParseMediaFields>>({ src, onVideoFrame, onAudioData, onProgress: onProgressDoNotCallDirectly, audioCodec, container, videoCodec, controller, onAudioTrack: userAudioResolver, onVideoTrack: userVideoResolver, reader, fields, logLevel, writer, progressIntervalInMs, rotate, resize, onAudioCodec, onContainer, onDimensions, onDurationInSeconds, onFps, onImages, onInternalStats, onIsHdr, onKeyframes, onLocation, onMetadata, onMimeType, onName, onNumberOfAudioChannels, onRotation, onSampleRate, onSize, onSlowAudioBitrate, onSlowDurationInSeconds, onSlowFps, onSlowKeyframes, onSlowNumberOfFrames, onSlowVideoBitrate, onSlowStructure, onTracks, onUnrotatedDimensions, onVideoCodec, onM3uStreams, selectM3uStream, selectM3uAssociatedPlaylists, expectedDurationInSeconds, expectedFrameRate, seekingHints, ...more }: {
    src: ParseMediaOptions<F>["src"];
    container: ConvertMediaContainer;
    onVideoFrame?: ConvertMediaOnVideoFrame;
    onAudioData?: ConvertMediaOnAudioData;
    onProgress?: ConvertMediaOnProgress;
    videoCodec?: ConvertMediaVideoCodec;
    audioCodec?: ConvertMediaAudioCodec;
    controller?: WebCodecsController;
    onAudioTrack?: ConvertMediaOnAudioTrackHandler;
    onVideoTrack?: ConvertMediaOnVideoTrackHandler;
    selectM3uStream?: ParseMediaOptions<F>["selectM3uStream"];
    selectM3uAssociatedPlaylists?: ParseMediaOptions<F>["selectM3uAssociatedPlaylists"];
    expectedDurationInSeconds?: number | null;
    expectedFrameRate?: number | null;
    reader?: ParseMediaOptions<F>["reader"];
    logLevel?: MediaParserLogLevel;
    writer?: MediaParserInternalTypes["WriterInterface"];
    progressIntervalInMs?: number;
    rotate?: number;
    resize?: ResizeOperation;
    fields?: F;
    seekingHints?: ParseMediaOptions<F>["seekingHints"];
} & MediaParserInternalTypes["ParseMediaCallbacks"]) => Promise<ConvertMediaResult>;
