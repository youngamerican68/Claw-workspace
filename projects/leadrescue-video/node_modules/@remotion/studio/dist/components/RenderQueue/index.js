"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenderQueue = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = __importStar(require("react"));
const remotion_1 = require("remotion");
const client_id_1 = require("../../helpers/client-id");
const colors_1 = require("../../helpers/colors");
const is_menu_item_1 = require("../Menu/is-menu-item");
const layout_1 = require("../layout");
const RenderQueueItem_1 = require("./RenderQueueItem");
const context_1 = require("./context");
const separatorStyle = {
    borderBottom: `1px solid ${colors_1.BORDER_COLOR}`,
};
const errorExplanation = {
    fontSize: 14,
    color: colors_1.LIGHT_TEXT,
    fontFamily: 'sans-serif',
    lineHeight: 1.5,
};
const explainer = {
    display: 'flex',
    flex: 1,
    flexDirection: 'column',
    padding: '0 12px',
    justifyContent: 'center',
    alignItems: 'center',
    textAlign: 'center',
    background: colors_1.BACKGROUND,
};
const renderQueue = {
    background: colors_1.BACKGROUND,
    flex: 1,
    overflowY: 'auto',
};
const RenderQueue = () => {
    const connectionStatus = (0, react_1.useContext)(client_id_1.StudioServerConnectionCtx)
        .previewServerState.type;
    const { jobs } = (0, react_1.useContext)(context_1.RenderQueueContext);
    const { canvasContent } = (0, react_1.useContext)(remotion_1.Internals.CompositionManager);
    const previousJobCount = react_1.default.useRef(jobs.length);
    const jobCount = jobs.length;
    const divRef = react_1.default.useRef(null);
    (0, react_1.useEffect)(() => {
        if (!divRef.current) {
            return;
        }
        // Scroll down to bottom of render queue if new jobs have been added
        if (jobCount > previousJobCount.current) {
            divRef.current.scrollTo({
                top: divRef.current.scrollHeight,
                behavior: 'smooth',
            });
        }
        previousJobCount.current = jobCount;
    }, [jobCount]);
    const selectedJob = (0, react_1.useMemo)(() => {
        if (!canvasContent) {
            return -1;
        }
        if (canvasContent.type === 'output-blob') {
            for (let i = 0; i < jobs.length; i++) {
                const job = jobs[i];
                if ((0, context_1.isClientRenderJob)(job) && job.status === 'done') {
                    if (canvasContent.getBlob === job.getBlob) {
                        return i;
                    }
                }
            }
            return -1;
        }
        if (canvasContent.type === 'output') {
            for (let i = 0; i < jobs.length; i++) {
                const job = jobs[i];
                if (!(0, context_1.isClientRenderJob)(job) &&
                    job.status === 'done' &&
                    canvasContent.path === `/${job.outName}`) {
                    return i;
                }
            }
        }
        return -1;
    }, [canvasContent, jobs]);
    if (connectionStatus === 'disconnected') {
        return ((0, jsx_runtime_1.jsxs)("div", { style: explainer, children: [(0, jsx_runtime_1.jsx)(layout_1.Spacing, { y: 5 }), (0, jsx_runtime_1.jsx)("div", { style: errorExplanation, children: "The studio server has disconnected." }), (0, jsx_runtime_1.jsx)(layout_1.Spacing, { y: 2, block: true })] }));
    }
    if (jobCount === 0) {
        return ((0, jsx_runtime_1.jsxs)("div", { style: explainer, children: [(0, jsx_runtime_1.jsx)(layout_1.Spacing, { y: 5 }), (0, jsx_runtime_1.jsx)("div", { style: errorExplanation, children: "No renders in the queue." }), (0, jsx_runtime_1.jsx)(layout_1.Spacing, { y: 2, block: true })] }));
    }
    return ((0, jsx_runtime_1.jsx)("div", { ref: divRef, style: renderQueue, className: ['css-reset', is_menu_item_1.VERTICAL_SCROLLBAR_CLASSNAME].join(' '), children: jobs.map((j, index) => {
            return ((0, jsx_runtime_1.jsx)("div", { style: index === jobs.length - 1 ? undefined : separatorStyle, children: (0, jsx_runtime_1.jsx)(RenderQueueItem_1.RenderQueueItem, { selected: selectedJob === index, job: j }) }, j.id));
        }) }));
};
exports.RenderQueue = RenderQueue;
